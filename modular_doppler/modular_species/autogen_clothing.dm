GLOBAL_LIST_EMPTY(bodyshape_autogen_clothing_cache)

/obj/item
	/// Assoc list of (BODYSHAPE_X (Stringified) -> /datum/greyscale_config). Used for generating autogenerated clothing on non-standard species.
	var/list/autogen_clothing_config
	/// [autogen_clothing_config], but used when the item is 1. a uniform and 2. does not cover the legs.
	var/list/autogen_clothing_config_skirt
	/// List of lists in format: (X, Y) coordinates. When an autogen clothing is made, these are the coordinates on the base sprite that will be used
	/// to determine the color of the created sprite.
	/// Add multiple entries if the target sprite template uses multiple colors.
	var/list/autogen_clothing_color_coords = null

/**
 * Modularly get the bodyshape's fallback greyscale config.
 * Only used if you use generate_autogen_worn_icon()
 *
 * Args:
 * * bodyshape: The stringified bodyshape we are considering.
 */
/obj/item/proc/get_autogen_worn_config(bodyshape_text)
	RETURN_TYPE(/datum/greyscale_config)

	return autogen_clothing_config?[bodyshape_text]

/obj/item/clothing/under/get_autogen_worn_config(bodyshape_text)
	. = ..()

	if ((body_parts_covered & LEGS) || isnull(autogen_clothing_config_skirt))
		return

	return autogen_clothing_config_skirt[bodyshape_text]

/obj/item/proc/use_autogen_worn_icon_cached()
	LAZYINITLIST(GLOB.bodyshape_autogen_clothing_cache[type])

/obj/item/proc/get_matching_bodyshape(mob/living/carbon/human/wearer)
	for (var/shape in autogen_clothing_config)
		if (shape == BODYSHAPE_HUMANOID_T) // EVERYTHING has this
			continue
		if (!(wearer.bodyshape & text2num(shape)))
			continue
		return shape

/**
 * Read from freely usable cache of generated icons.
 * Arguments:
 * * file_to_use: icon you're substituting
 * * state_to_use: icon state you're substituting
 * * meta: string containing other info.
 */
/obj/item/proc/get_autogen_worn_icon_cached(file_to_use, state_to_use, meta)
	RETURN_TYPE(/icon)

	return GLOB.bodyshape_autogen_clothing_cache[type]["[file_to_use]-[state_to_use]-[meta]"]

/**
 * Write to a freely usable cache of generated icons.
 * Arguments:
 * * file_to_use: icon you're substituting
 * * state_to_use: icon state you're substituting
 * * meta: string containing other info.
 * * cached_value: Cached value
 */
/obj/item/proc/set_autogen_worn_icon_cached(file_to_use, state_to_use, meta, icon/cached_value)
	GLOB.bodyshape_autogen_clothing_cache[type]["[file_to_use]-[state_to_use]-[meta]"] = cached_value

/**
 * Generate a fallback worn icon, if the item supports it.
 * Arguments:
 * * bodyshape_text: The bodyshape we are generating for.
 *
 * Returns:
 * * A /icon, or null, if no sprite could be generated.
 */
/obj/item/proc/generate_autogen_worn_icon(bodyshape_text, item_slot)
	RETURN_TYPE(/icon)

	var/icon/human_icon = worn_icon || icon
	var/human_icon_state = worn_icon_state || icon_state

	// First, let's just check if we've already made this.
	use_autogen_worn_icon_cached()
	var/icon/cached_icon = get_autogen_worn_icon_cached(human_icon, human_icon_state, greyscale_colors || "x")
	if(cached_icon)
		if(!(human_icon_state in icon_states(cached_icon)))
			cached_icon.Insert(cached_icon, icon_state = human_icon_state) // include the expected icon_state
		return cached_icon

	// Get GAGs config
	var/fallback_config = get_autogen_worn_config(bodyshape_text)
	if(!fallback_config)
		return null

	// The GAGs config needs this many colors.
	var/expected_num_colors = SSgreyscale.configurations["[fallback_config]"].expected_colors
	// The colors string.
	var/fallback_greyscale_colors

	// If this outfit is already GAGs, use the existing colors.
	if(greyscale_colors)
		// Just use the colors already given to us, but re-align to expected colors.
		var/list/colors = SSgreyscale.ParseColorString(greyscale_colors)
		var/default_color = (length(colors) >= 1) ? colors[1] : COLOR_DARK
		var/list/final_list = list()
		for(var/i in 1 to expected_num_colors)
			final_list += (i < length(colors)) ? colors[i] : default_color
		fallback_greyscale_colors = final_list.Join("")
	else
		// OK, we have to actually guess the colors.
		var/icon/final_human_icon = icon(human_icon, human_icon_state)
		var/list/color_list = list()

		for(var/i in 1 to expected_num_colors)
			if(isnull(autogen_clothing_color_coords) || \
			length(autogen_clothing_color_coords) < i)
				color_list += COLOR_DARK
				continue
			var/coord = autogen_clothing_color_coords[i]
			color_list += final_human_icon.GetPixel(coord[1], coord[2]) || COLOR_DARK

		fallback_greyscale_colors = color_list.Join("")

	// Finally, render with GAGs
	var/icon/final_icon = icon(SSgreyscale.GetColoredIconByType(get_autogen_worn_config(bodyshape_text), fallback_greyscale_colors))
	// Duplicate to the specific icon_state and set.
	final_icon.Insert(final_icon, icon_state = human_icon_state) // include the expected icon_state
	// Cache the clean copy.
	set_autogen_worn_icon_cached(human_icon, human_icon_state, greyscale_colors || "x", final_icon)

	var/mob/living/carbon/wearer = null
	if (iscarbon(loc))
		wearer = loc
	final_icon = do_bodyshape_modifiers(final_icon, bodyshape_text, wearer?.bodyshape, item_slot)

	return final_icon

/**
 * Modifies the autogenerated sprite, final_icon, by [bodyshape_text] and the bodyshapes found in [all_bodyshapes]. Used for making autogenerated sprites
 * fit better.
 *
 * Args:
 * * icon/final_icon: The icon to be modified.
 * * bodyshape_text: The stringified bodyshape this autogenerated sprite was created for.
 * * all_bodyshapes: The bitfield of the wearer's bodyshapes.
 * * item_slot: The item slot the icon was generated for.
 */
/obj/item/proc/do_bodyshape_modifiers(icon/final_icon, bodyshape_text, all_bodyshapes, item_slot)
	if (bodyshape_text == BODYSHAPE_SNOUTED_T && (all_bodyshapes & BODYSHAPE_TESHARI))
		if ((item_slot == OFFSET_FACEMASK || item_slot == OFFSET_HEAD) && (supported_bodyshapes & BODYSHAPE_SNOUTED))
			if (!ishuman(loc))
				return final_icon
			var/human_icon = bodyshape_icon_files[BODYSHAPE_SNOUTED_T]
			var/human_icon_state = worn_icon_state || icon_state

			// Did the snout variation flag lie to us?
			if(!icon_exists(human_icon, human_icon_state))
				return

			// Use already resolved icon
			use_autogen_worn_icon_cached()
			var/icon/cached_icon = get_autogen_worn_icon_cached(human_icon, human_icon_state, "m")
			if(cached_icon)
				return cached_icon

			// Generate muzzled icon
			var/icon/new_icon = icon('icons/blanks/32x32.dmi', "nothing")
			new_icon.Blend(icon(human_icon, human_icon_state), ICON_OVERLAY)
			new_icon.Insert(new_icon, human_icon_state)
			set_autogen_worn_icon_cached(human_icon, human_icon_state, "m", new_icon)

			return new_icon

	return final_icon

